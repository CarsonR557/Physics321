<!DOCTYPE html>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="PHY321: Review of Vectors, Math and first Numerical Examples for simple Motion Problems">

<title>PHY321: Review of Vectors, Math and first Numerical Examples for simple Motion Problems</title>







<!-- reveal.js: http://lab.hakim.se/reveal-js/ -->

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
<!--
<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/beigesmall.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/solarized.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/serif.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/moon.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/sky.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/darkgray.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/default.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/cbc.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/simula.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/league.css" id="theme">
-->

<!-- For syntax highlighting -->
<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

<!-- Printing and PDF exports -->
<script>
var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
document.getElementsByTagName( 'head' )[0].appendChild( link );
</script>

<style type="text/css">
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
    hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .reveal .alert-text-small   { font-size: 80%;  }
    .reveal .alert-text-large   { font-size: 130%; }
    .reveal .alert-text-normal  { font-size: 90%;  }
    .reveal .alert {
             padding:8px 35px 8px 14px; margin-bottom:18px;
             text-shadow:0 1px 0 rgba(255,255,255,0.5);
             border:5px solid #bababa;
             -webkit-border-radius: 14px; -moz-border-radius: 14px;
             border-radius:14px;
             background-position: 10px 10px;
             background-repeat: no-repeat;
             background-size: 38px;
             padding-left: 30px; /* 55px; if icon */
     }
     .reveal .alert-block {padding-top:14px; padding-bottom:14px}
     .reveal .alert-block > p, .alert-block > ul {margin-bottom:1em}
     /*.reveal .alert li {margin-top: 1em}*/
     .reveal .alert-block p+p {margin-top:5px}
     /*.reveal .alert-notice { background-image: url(http://hplgit.github.io/doconce/bundled/html_images/small_gray_notice.png); }
     .reveal .alert-summary  { background-image:url(http://hplgit.github.io/doconce/bundled/html_images/small_gray_summary.png); }
     .reveal .alert-warning { background-image: url(http://hplgit.github.io/doconce/bundled/html_images/small_gray_warning.png); }
     .reveal .alert-question {background-image:url(http://hplgit.github.io/doconce/bundled/html_images/small_gray_question.png); } */

</style>



<!-- Styles for table layout of slides -->
<style type="text/css">
td.padding {
  padding-top:20px;
  padding-bottom:20px;
  padding-right:50px;
  padding-left:50px;
}
</style>

</head>

<body>
<div class="reveal">

<!-- Any section element inside the <div class="slides"> container
     is displayed as a slide -->

<div class="slides">





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



    



<section>
<!-- ------------------- main content ---------------------- -->



<center><h1 style="text-align: center;">PHY321: Review of Vectors, Math and first Numerical Examples for simple Motion Problems</h1></center>  <!-- document title -->

<p>
<!-- author(s): <a href="http://mhjgit.github.io/info/doc/web/" target="_blank">Morten Hjorth-Jensen</a> -->

<center>
<b><a href="http://mhjgit.github.io/info/doc/web/" target="_blank">Morten Hjorth-Jensen</a></b> [1, 2]
</center>

<p>&nbsp;<br>
<!-- institution(s) -->

<center>[1] <b>Department of Physics and Astronomy and Facility for Rare Ion Beams (FRIB), Michigan State University, USA</b></center>
<center>[2] <b>Department of Physics, University of Oslo, Norway</b></center>
<br>
<p>&nbsp;<br>
<center><h4>Jan 6, 2021</h4></center> <!-- date -->
<br>
<p>

<center style="font-size:80%">
<!-- copyright --> &copy; 1999-2021, "Morten Hjorth-Jensen":"http://mhjgit.github.io/info/doc/web/". Released under CC Attribution-NonCommercial 4.0 license
</center>
</section>


<section>
<h2 id="___sec0">Aims and Overarching Motivation </h2>

<h3 id="___sec1">Wednesday </h3>

<h3 id="___sec2">Friday </h3>
</section>


<section>
<h2 id="___sec3">Space, Time, Motion, Reference Frames  and Reminder on vectors and other mathematical quantities </h2>

<p>
Our studies will start with the motion of different types of objects
such as a falling ball, a runner, a bicycle etc etc. It means that an
object's position in space varies with time.
In order to study such systems we need to define

<ul>
<p><li> choice of origin</li>
<p><li> choice of the direction of the axes</li>
<p><li> choice of positive direction (left-handed or right-handed system of reference)</li>
<p><li> choice of units and dimensions</li>
</ul>
<p>

These choices lead to some important questions such as

<ul>
<p><li> is the  physics of a system independent of the origin of the axes?</li>
<p><li> is the  physics independent of the directions of the axes, that is are there privileged axes?</li>
<p><li> is the physics independent of the orientation of system?</li>
<p><li> is the physics independent of the scale of the length?</li>
</ul>

<h3 id="___sec4">Dimension, units and labels </h3>

<p>
Throughout this course we will use the standardized SI units. The standard unit for length is thus one meter 1m, for mass
one kilogram 1kg, for time one second 1s, for force one Newton 1kgm/s$^2$ and for energy 1 Joule 1kgm$^2$s$^{-2}$.

<p>
We will use the following notations for various variables (vectors are always boldfaced in these lecture notes):

<ul>
<p><li> position \( \boldsymbol{r} \), in one dimention we will normally just use \( x \),</li>
<p><li> mass \( m \),</li>
<p><li> time \( t \),</li>
<p><li> velocity \( \boldsymbol{v} \) or just \( v \) in one dimension,</li>
<p><li> acceleration \( \boldsymbol{a} \) or just \( a \) in one dimension,</li>
<p><li> momentum \( \boldsymbol{p} \) or just \( p \) in one dimension,</li>
<p><li> kinetic energy \( K \),</li>
<p><li> potential energy \( V \) and</li>
<p><li> frequency \( \omega \).</li>
</ul>
<p>

More variables will be defined as we need them.

<p>
It is also important to keep track of dimensionalities. Don't mix this up with a chosen unit for a given variable. We mark the dimensionality in these lectures as \( [a] \), where \( a \) is the quantity we are interested in. Thus

<ul>
<p><li> \( [\boldsymbol{r}]= \) length</li>
<p><li> \( [m]= \) mass</li>
<p><li> \( [K]= \) energy</li>
<p><li> \( [t]= \) time</li>
<p><li> \( [\boldsymbol{v}]= \) length over time</li>
<p><li> \( [\boldsymbol{a}]= \) length over time squared</li>
<p><li> \( [\boldsymbol{p}]= \) mass times length over time</li>
<p><li> \( [\omega]= \) 1/time</li>
</ul>
</section>


<section>
<h2 id="___sec5">Elements of Vector Algebra </h2>

<p>
<b>Note</b>: This section is under revision

<p>
In these lectures we will use boldfaced lower-case letters to label a vector. A vector \( \boldsymbol{a} \) in three dimensions is thus defined as
<p>&nbsp;<br>
$$
\boldsymbol{a} =(a_x,a_y, a_z),
$$
<p>&nbsp;<br>

and using the unit vectors in a cartesian system we have
<p>&nbsp;<br>
$$
\boldsymbol{a} = a_x\boldsymbol{e}_x+a_y\boldsymbol{e}_y+a_z\boldsymbol{e}_z,
$$
<p>&nbsp;<br>

where the unit vectors have magnitude \( \vert\boldsymbol{e}_i\vert = 1 \) with \( i=x,y,z \).

<p>
Using the fact that multiplication of reals is distributive we can show that
<p>&nbsp;<br>
$$
\boldsymbol{a}(\boldsymbol{b}+\boldsymbol{c})=\boldsymbol{a}\boldsymbol{b}+\boldsymbol{a}\boldsymbol{c},
$$
<p>&nbsp;<br>

Similarly we can also show that (using product rule for differentiating reals)
<p>&nbsp;<br>
$$
\frac{d}{dt}(\boldsymbol{a}\boldsymbol{b})=\boldsymbol{a}\frac{d\boldsymbol{b}}{dt}+\boldsymbol{b}\frac{d\boldsymbol{a}}{dt}.
$$
<p>&nbsp;<br>

<p>
We can repeat these operations for the cross products and show that they are distribuitive
<p>&nbsp;<br>
$$
\boldsymbol{a}\times(\boldsymbol{b}+\boldsymbol{c})=\boldsymbol{a}\times\boldsymbol{b}+\boldsymbol{a}\times\boldsymbol{c}.
$$
<p>&nbsp;<br>

We have also that
<p>&nbsp;<br>
$$
\frac{d}{dt}(\boldsymbol{a}\times\boldsymbol{b})=\boldsymbol{a}\times\frac{d\boldsymbol{b}}{dt}+\boldsymbol{b}\times\frac{d\boldsymbol{a}}{dt}.
$$
<p>&nbsp;<br>

The rotation of a three-dimensional  vector \( \boldsymbol{a}=(a_x,a_y,a_z) \) in the \( xy \) plane around an angle \( \phi \) results in a new vector \( \boldsymbol{b}=(b_x,b_y,b_z) \).  This operation can be expressed in terms of linear algebra as a matrix (the rotation matrix) multiplied with a vector. We can write this as
<p>&nbsp;<br>
$$
\begin{bmatrix} b_x \\ b_y \\ b_z \end{bmatrix} = \begin{bmatrix} \cos{\phi} & \sin{\phi} & 0 \\ -\sin{\phi} & \cos{\phi} & 0 \\ 0 & 0 & 1\end{bmatrix}\begin{bmatrix} a_x \\ a_y \\ a_z \end{bmatrix}.
$$
<p>&nbsp;<br>

We can write this in a more compact form as \( \boldsymbol{b} = \boldsymbol{R}\boldsymbol{a} \), where the rotation matrix is defined as
<p>&nbsp;<br>
$$
\boldsymbol{R} = \begin{bmatrix} \cos{\phi} & \sin{\phi} & 0 \\ -\sin{\phi} & \cos{\phi} & 0 \\ 0 & 0 & 1\end{bmatrix}.
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="___sec6">Falling baseball in one dimension </h2>

<p>
We anticipate the mathematical model to come and assume that we have a
model for the motion of a falling baseball without air resistance.
Our system (the baseball) is at an initial height \( y_0 \) (which we will
specify in the program below) at the initial time \( t_0=0 \). In our program example here we will plot the position in steps of \( \Delta t \) up to a final time \( t_f \). 
The mathematical formula for the position \( y(t) \) as function of time \( t \) is 
<p>&nbsp;<br>
$$
y(t) = y_0-\frac{1}{2}gt^2,
$$
<p>&nbsp;<br>

where $g=9.80665=0.980655\times 10^1$m/s${}^2$ is a constant representing the standard acceleration due to gravity.
We have here adopted the conventional standard value. This does not take into account other effects, such as buoyancy or drag.
Furthermore, we stop when the ball hits the ground, which takes place at
<p>&nbsp;<br>
$$
y(t) = 0= y_0-\frac{1}{2}gt^2,
$$
<p>&nbsp;<br>

which gives us a final time \( t_f=\sqrt{2y_0/g} \).

<p>
As of now we simply assume that   we know the formula for the falling object. Afterwards, we will derive it.
</section>


<section>
<h2 id="___sec7">Our Python Encounter </h2>

<p>
We start with preparing folders for storing our calculations, figures and if needed, specific data files we use as input or output files.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%"><span></span><span style="color: #228B22"># Common imports</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">pandas</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">pd</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">os</span>

<span style="color: #228B22"># Where to save the figures and data files</span>
PROJECT_ROOT_DIR = <span style="color: #CD5555">&quot;Results&quot;</span>
FIGURE_ID = <span style="color: #CD5555">&quot;Results/FigureFiles&quot;</span>
DATA_ID = <span style="color: #CD5555">&quot;DataFiles/&quot;</span>

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(PROJECT_ROOT_DIR):
    os.mkdir(PROJECT_ROOT_DIR)

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(FIGURE_ID):
    os.makedirs(FIGURE_ID)

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(DATA_ID):
    os.makedirs(DATA_ID)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">image_path</span>(fig_id):
    <span style="color: #8B008B; font-weight: bold">return</span> os.path.join(FIGURE_ID, fig_id)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">data_path</span>(dat_id):
    <span style="color: #8B008B; font-weight: bold">return</span> os.path.join(DATA_ID, dat_id)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">save_fig</span>(fig_id):
    plt.savefig(image_path(fig_id) + <span style="color: #CD5555">&quot;.png&quot;</span>, <span style="color: #658b00">format</span>=<span style="color: #CD5555">&#39;png&#39;</span>)

<span style="color: #228B22">#in case we have an input file we wish to read in</span>
<span style="color: #228B22">#infile = open(data_path(&quot;MassEval2016.dat&quot;),&#39;r&#39;)</span>
</pre></div>
<p>
You could also define a function for making our plots. You
can obviously avoid this and simply set up various <b>matplotlib</b>
commands every time you need them. You may however find it convenient
to collect all such commands in one function and simply call this
function.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%"><span></span><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">pylab</span> <span style="color: #8B008B; font-weight: bold">import</span> plt, mpl
plt.style.use(<span style="color: #CD5555">&#39;seaborn&#39;</span>)
mpl.rcParams[<span style="color: #CD5555">&#39;font.family&#39;</span>] = <span style="color: #CD5555">&#39;serif&#39;</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">MakePlot</span>(x,y, styles, labels, axlabels):
    plt.figure(figsize=(<span style="color: #B452CD">10</span>,<span style="color: #B452CD">6</span>))
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(x)):
        plt.plot(x[i], y[i], styles[i], label = labels[i])
        plt.xlabel(axlabels[<span style="color: #B452CD">0</span>])
        plt.ylabel(axlabels[<span style="color: #B452CD">1</span>])
    plt.legend(loc=<span style="color: #B452CD">0</span>)
</pre></div>
<p>
Thereafter we start setting up the code for the falling object.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%"><span></span>%matplotlib inline
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.patches</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">mpatches</span>

g = <span style="color: #B452CD">9.80655</span> <span style="color: #228B22">#m/s^2</span>
y_0 = <span style="color: #B452CD">10.0</span> <span style="color: #228B22"># initial position in meters</span>
DeltaT = <span style="color: #B452CD">0.1</span>  <span style="color: #228B22"># time step</span>
<span style="color: #228B22"># final time when y = 0, t = sqrt(2*10/g)</span>
tfinal = np.sqrt(<span style="color: #B452CD">2.0</span>*y_0/g)
<span style="color: #228B22">#set up arrays </span>
t = np.arange(<span style="color: #B452CD">0</span>,tfinal,DeltaT)
y =y_0 -g*.<span style="color: #B452CD">5</span>*t**<span style="color: #B452CD">2</span>
<span style="color: #228B22"># Then make a nice printout in table form using Pandas</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">pandas</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">pd</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">IPython.display</span> <span style="color: #8B008B; font-weight: bold">import</span> display
data = {<span style="color: #CD5555">&#39;t[s]&#39;</span>: t,
        <span style="color: #CD5555">&#39;y[m]&#39;</span>: y
        }
RawData = pd.DataFrame(data)
display(RawData)
plt.style.use(<span style="color: #CD5555">&#39;ggplot&#39;</span>)
plt.figure(figsize=(<span style="color: #B452CD">8</span>,<span style="color: #B452CD">8</span>))
plt.scatter(t, y, color = <span style="color: #CD5555">&#39;b&#39;</span>)
blue_patch = mpatches.Patch(color = <span style="color: #CD5555">&#39;b&#39;</span>, label = <span style="color: #CD5555">&#39;Height y as function of  time t&#39;</span>)
plt.legend(handles=[blue_patch])
plt.xlabel(<span style="color: #CD5555">&quot;t[s]&quot;</span>)
plt.ylabel(<span style="color: #CD5555">&quot;y[m]&quot;</span>)
save_fig(<span style="color: #CD5555">&quot;FallingBaseball&quot;</span>)
plt.show()
</pre></div>
<p>
Here we used <b>pandas</b> (see below) to systemize the output of the position as function of time.
</section>


<section>
<h2 id="___sec8">Average quantities </h2>
We define now the average velocity as
<p>&nbsp;<br>
$$
\overline{v}(t) = \frac{y(t+\Delta t)-y(t)}{\Delta t}.
$$
<p>&nbsp;<br>

In the code we have set the time step \( \Delta t \) to a given value. We could define it in terms of the number of points \( n \) as
<p>&nbsp;<br>
$$
\Delta t = \frac{t_{\mathrm{final}-}t_{\mathrm{initial}}}{n+1}.
$$
<p>&nbsp;<br>

<p>
Since we have discretized the variables, we introduce the counter \( i \) and let \( y(t)\rightarrow y(t_i)=y_i \) and \( t\rightarrow t_i \)
with \( i=0,1,\dots, n \). This gives us the following shorthand notations that we will use for the rest of this course. We define
<p>&nbsp;<br>
$$
y_i = y(t_i),\hspace{0.2cm} i=0,1,2,\dots,n.
$$
<p>&nbsp;<br>

This applies to other variables which depend on say time. Examples are the velocities, accelerations, momenta etc.
Furthermore we use the shorthand
<p>&nbsp;<br>
$$
y_{i\pm 1} = y(t_i\pm \Delta t),\hspace{0.12cm} i=0,1,2,\dots,n.
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="___sec9">Compact equations </h2>
We can then rewrite in a more compact form the average velocity as
<p>&nbsp;<br>
$$
\overline{v}_i = \frac{y_{i+1}-y_{i}}{\Delta t}.
$$
<p>&nbsp;<br>

The velocity is defined as the change in position per unit time.
In the limit \( \Delta t \rightarrow 0 \) this defines the instantaneous velocity, which is nothing but the slope of the position at a time \( t \).
We have thus
<p>&nbsp;<br>
$$
v(t) = \frac{dy}{dt}=\lim_{\Delta t \rightarrow 0}\frac{y(t+\Delta t)-y(t)}{\Delta t}.
$$
<p>&nbsp;<br>

Similarly, we can define the average acceleration as the change in velocity per unit time as
<p>&nbsp;<br>
$$
\overline{a}_i = \frac{v_{i+1}-v_{i}}{\Delta t},
$$
<p>&nbsp;<br>

resulting in the instantaneous acceleration
<p>&nbsp;<br>
$$
a(t) = \frac{dv}{dt}=\lim_{\Delta t\rightarrow 0}\frac{v(t+\Delta t)-v(t)}{\Delta t}.
$$
<p>&nbsp;<br>

<p>
<b>A note on notations</b>: When writing for example the velocity as \( v(t) \) we are then referring to the continuous and instantaneous value. A subscript like
\( v_i \) refers always to the discretized values.
</section>


<section>
<h2 id="___sec10">A differential equation </h2>
We can rewrite the instantaneous acceleration as
<p>&nbsp;<br>
$$
a(t) = \frac{dv}{dt}=\frac{d}{dt}\frac{dy}{dt}=\frac{d^2y}{dt^2}.
$$
<p>&nbsp;<br>

This forms the starting point for our definition of forces later. It is a famous second-order differential equation. If the acceleration is constant we can now recover the formula for the falling ball we started with.
The acceleration can depend on the position and the velocity. To be more formal we should then write the above differential equation as
<p>&nbsp;<br>
$$
\frac{d^2y}{dt^2}=a(t,y(t),\frac{dy}{dt}).
$$
<p>&nbsp;<br>

<p>
With given initial conditions for \( y(t_0) \) and \( v(t_0) \) we can then
integrate the above equation and find the velocities and positions at
a given time \( t \).

<p>
If we multiply with mass, we have one of the famous expressions for Newton's second law,
<p>&nbsp;<br>
$$
F(y,v,t)=m\frac{d^2y}{dt^2}=ma(t,y(t),\frac{dy}{dt}),
$$
<p>&nbsp;<br>

where \( F \) is the force acting on an object with mass \( m \). We see that it also has the right dimension, mass times length divided by time squared.
We will come back to this soon.
</section>


<section>
<h2 id="___sec11">Integrating our equations </h2>

<p>
Formally we can then, starting with the acceleration (suppose we have measured it, how could we do that?)
compute say the height of a building.  To see this we perform the following integrations from an initial time \( t_0 \)  to a given time \( t \)
<p>&nbsp;<br>
$$
\int_{t_0}^t dt a(t) = \int_{t_0}^t dt \frac{dv}{dt} = v(t)-v(t_0),
$$
<p>&nbsp;<br>

or as 
<p>&nbsp;<br>
$$
v(t)=v(t_0)+\int_{t_0}^t dt a(t).
$$
<p>&nbsp;<br>

<p>
When we know the velocity as function of time, we can find the position as function of time starting from the defintion of velocity as the derivative with respect to time, that is we have
<p>&nbsp;<br>
$$
\int_{t_0}^t dt v(t) = \int_{t_0}^t dt \frac{dy}{dt} = y(t)-y(t_0),
$$
<p>&nbsp;<br>

or as 
<p>&nbsp;<br>
$$
y(t)=y(t_0)+\int_{t_0}^t dt v(t).
$$
<p>&nbsp;<br>

<p>
These equations define what is called the integration method for
finding the position and the velocity as functions of time. There is
no loss of generality if we extend these equations to more than one
spatial dimension.
</section>


<section>
<h2 id="___sec12">Constant acceleration case, the velocity </h2>
Let us compute the velocity using the constant value for the acceleration given by \( -g \). We have
<p>&nbsp;<br>
$$
v(t)=v(t_0)+\int_{t_0}^t dt a(t)=v(t_0)+\int_{t_0}^t dt (-g).
$$
<p>&nbsp;<br>

Using our initial time as $t_0=0$s and setting the initial velocity $v(t_0)=v_0=0$m/s we get when integrating
<p>&nbsp;<br>
$$
v(t)=-gt.
$$
<p>&nbsp;<br>

The more general case is
<p>&nbsp;<br>
$$
v(t)=v_0-g(t-t_0).
$$
<p>&nbsp;<br>

We can then integrate the velocity and obtain the final formula for the position as function of time through
<p>&nbsp;<br>
$$
y(t)=y(t_0)+\int_{t_0}^t dt v(t)=y_0+\int_{t_0}^t dt v(t)=y_0+\int_{t_0}^t dt (-gt),
$$
<p>&nbsp;<br>

With $y_0=10$m and $t_0=0$s, we obtain the equation we started with
<p>&nbsp;<br>
$$
y(t)=10-\frac{1}{2}gt^2.
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="___sec13">Computing the averages </h2>
After this mathematical background we are now ready to compute the mean velocity using our data.
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%"><span></span><span style="color: #228B22"># Now we can compute the mean velocity using our data</span>
<span style="color: #228B22"># We define first an array Vaverage</span>
n = np.size(t)
Vaverage = np.zeros(n)
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>,n-<span style="color: #B452CD">1</span>):
    Vaverage[i] = (y[i+<span style="color: #B452CD">1</span>]-y[i])/DeltaT
<span style="color: #228B22"># Now we can compute the mean accelearatio using our data</span>
<span style="color: #228B22"># We define first an array Aaverage</span>
n = np.size(t)
Aaverage = np.zeros(n)
Aaverage[<span style="color: #B452CD">0</span>] = -g
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>,n-<span style="color: #B452CD">1</span>):
    Aaverage[i] = (Vaverage[i+<span style="color: #B452CD">1</span>]-Vaverage[i])/DeltaT
data = {<span style="color: #CD5555">&#39;t[s]&#39;</span>: t,
        <span style="color: #CD5555">&#39;y[m]&#39;</span>: y,
        <span style="color: #CD5555">&#39;v[m/s]&#39;</span>: Vaverage,
        <span style="color: #CD5555">&#39;a[m/s^2]&#39;</span>: Aaverage
        }
NewData = pd.DataFrame(data)
display(NewData[<span style="color: #B452CD">0</span>:n-<span style="color: #B452CD">2</span>])
</pre></div>
<p>
Note that we don't print the last values!
</section>


<section>
<h2 id="___sec14">Including Air Resistance in our model </h2>

<p>
In our discussions till now of the falling baseball, we have ignored
air resistance and simply assumed that our system is only influenced
by the gravitational force.  We will postpone the derivation of air
resistance till later, after our discussion of Newton's laws and
forces.

<p>
For our discussions here it suffices to state that the accelerations is now modified to
<p>&nbsp;<br>
$$
\boldsymbol{a}(t) = -g +D\boldsymbol{v}(t)\vert v(t)\vert,
$$
<p>&nbsp;<br>

where \( \vert v(t)\vert \) is the absolute value of the velocity and \( D \) is a constant which pertains to the specific object we are studying.
Since we are dealing with motion in one dimension, we can simplify the above to
<p>&nbsp;<br>
$$
a(t) = -g +Dv^2(t). 
$$
<p>&nbsp;<br>

We can rewrite this as a differential equation
<p>&nbsp;<br>
$$
a(t) = \frac{dv}{dt}=\frac{d^2y}{dt^2}= -g +Dv^2(t). 
$$
<p>&nbsp;<br>

<p>
Using the integral equations discussed above we can integrate twice
and obtain first the velocity as function of time and thereafter the
position as function of time.

<p>
For this particular case, we can actually obtain an analytical
solution for the velocity and for the position. Here we will first
compute the solutions analytically, thereafter we will derive Euler's
method for solving these differential equations numerically.
</section>


<section>
<h2 id="___sec15">Analytical solutions </h2>

<p>
For simplicity let us just write \( v(t) \) as \( v \). We have
<p>&nbsp;<br>
$$
\frac{dv}{dt}= -g +Dv^2(t). 
$$
<p>&nbsp;<br>

<p>
We can solve this using the technique of separation of variables. We
isolate on the left all terms that involve \( v \) and on the right all
terms that involve time. We get then
<p>&nbsp;<br>
$$
\frac{dv}{g -Dv^2(t) }= -dt,
$$
<p>&nbsp;<br>

<p>
We scale now the equation to the left by introducing a constant
\( v_T=\sqrt{g/D} \). This constant has dimension length/time. Can you
show this?

<p>
Next we integrate the left-hand side (lhs) from \( v_0=0 \) m/s to \( v \) and
the right-hand side (rhs) from \( t_0=0 \) to \( t \) and obtain

<p>&nbsp;<br>
$$
\int_{0}^v\frac{dv}{g -Dv^2(t) }= \frac{v_T}{g}\mathrm{arctanh}(\frac{v}{v_T})  =-\int_0^tdt = -t. 
$$
<p>&nbsp;<br>

We can reorganize these equations as
<p>&nbsp;<br>
$$
v_T\mathrm{arctanh}(\frac{v}{v_T})  =-gt,
$$
<p>&nbsp;<br>

which gives us \( v \) as function of time
<p>&nbsp;<br>
$$
v(t)=v_T\tanh{-(\frac{gt}{v_T})}.
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="___sec16">Finding the final height </h2>
With the velocity we can then find the height \( y(t) \) by integrating yet another time, that is
<p>&nbsp;<br>
$$
y(t)=y(t_0)+\int_{t_0}^t dt v(t)=\int_{0}^t dt[v_T\tanh{-(\frac{gt}{v_T})}]. 
$$
<p>&nbsp;<br>

This integral is a little bit trickier but we can look it up in a table over 
known integrals and we get
<p>&nbsp;<br>
$$
y(t)=y(t_0)-\frac{v_T^2}{g}\log{[\cosh{(\frac{gt}{v_T})}]}.
$$
<p>&nbsp;<br>

Alternatively we could have used the symbolic Python package <b>Sympy</b>  (example will be inserted later).

<p>
In most cases however, we need to revert to numerical solutions.
</section>


<section>
<h2 id="___sec17">Our first attempt at solving differential equations </h2>

<p>
Here we will try the simplest possible approach to solving the second-order differential 
equation
<p>&nbsp;<br>
$$
a(t) =\frac{d^2y}{dt^2}= -g +Dv^2(t). 
$$
<p>&nbsp;<br>

We rewrite it as two coupled first-order equations (this is a standard approach)
<p>&nbsp;<br>
$$
\frac{dy}{dt} = v(t),
$$
<p>&nbsp;<br>

with initial condition \( y(t_0)=y_0 \) and 
<p>&nbsp;<br>
$$
a(t) =\frac{dv}{dt}= -g +Dv^2(t),
$$
<p>&nbsp;<br>

with initial condition \( v(t_0)=v_0 \).

<p>
Many of the algorithms for solving differential equations start with simple Taylor equations.
If we now Taylor expand \( y \) and \( v \) around a value \( t+\Delta t \) we have
<p>&nbsp;<br>
$$
y(t+\Delta t) = y(t)+\Delta t \frac{dy}{dt}+\frac{\Delta t^2}{2!} \frac{d^2y}{dt^2}+O(\Delta t^3),
$$
<p>&nbsp;<br>

and
<p>&nbsp;<br>
$$
v(t+\Delta t) = v(t)+\Delta t \frac{dv}{dt}+\frac{\Delta t^2}{2!} \frac{d^2v}{dt^2}+O(\Delta t^3).
$$
<p>&nbsp;<br>

Using the fact that \( dy/dt = v \) and \( dv/dt=a \) and keeping only terms up to \( \Delta t \) we have
<p>&nbsp;<br>
$$
y(t+\Delta t) = y(t)+\Delta t v(t)+O(\Delta t^2),
$$
<p>&nbsp;<br>

and
<p>&nbsp;<br>
$$
v(t+\Delta t) = v(t)+\Delta t a(t)+O(\Delta t^2).
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="___sec18">Discretizing our equations </h2>
Using our discretized versions of the equations with for example
\( y_{i}=y(t_i) \) and \( y_{i\pm 1}=y(t_i+\Delta t) \), we can rewrite the
above equations as (and truncating at \( \Delta t \))

<p>&nbsp;<br>
$$
y_{i+1} = y_i+\Delta t v_i,
$$
<p>&nbsp;<br>

and
<p>&nbsp;<br>
$$
v_{i+1} = v_i+\Delta t a_i.
$$
<p>&nbsp;<br>

These are the famous Euler equations (forward Euler).

<p>
To solve these equations numerically we start at a time \( t_0 \) and simply integrate up these equations to a final time \( t_f \),
The step size \( \Delta t \) is an input  parameter in our code.
You can define it directly in the code below as
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%"><span></span>DeltaT = <span style="color: #B452CD">0.1</span>
</pre></div>
<p>
With a given final time <b>tfinal</b>  we can then find the number of integration points via the <b>ceil</b> function included in the <b>math</b> package of Python
as
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%"><span></span><span style="color: #228B22">#define final time, assuming that initial time is zero</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">import</span> ceil
tfinal = <span style="color: #B452CD">0.5</span>
n = ceil(tfinal/DeltaT)
<span style="color: #658b00">print</span>(n)
</pre></div>
<p>
The <b>ceil</b> function returns the smallest integer not less than the input in say
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%"><span></span>x = <span style="color: #B452CD">21.15</span>
<span style="color: #658b00">print</span>(ceil(x))
</pre></div>
<p>
which in the case here is 22.
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%"><span></span>x = <span style="color: #B452CD">21.75</span>
<span style="color: #658b00">print</span>(ceil(x))
</pre></div>
<p>
which also yields 22. The  <b>floor</b> function in the <b>math</b> package
is used to return the closest integer value which is less than or equal to the specified expression or value.
Compare the previous result to the usage of <b>floor</b>
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%"><span></span><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">import</span> floor
x = <span style="color: #B452CD">21.75</span>
<span style="color: #658b00">print</span>(floor(x))
</pre></div>
<p>
Alternatively, we can define ourselves the number of integration(mesh) points. In this case we could have
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%"><span></span>n = <span style="color: #B452CD">10</span>
tinitial = <span style="color: #B452CD">0.0</span>
tfinal = <span style="color: #B452CD">0.5</span>
DeltaT = (tfinal-tinitial)/(n)
<span style="color: #658b00">print</span>(DeltaT)
</pre></div>
<p>
Since we will set up one-dimensional arrays that contain the values of
various variables like time, position, velocity, acceleration etc, we
need to know the value of \( n \), the number of data points (or
integration or mesh points).  With \( n \) we can initialize a given array
by setting all elelements to zero, as done here

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%"><span></span><span style="color: #228B22"># define array a</span>
a = np.zeros(n)
<span style="color: #658b00">print</span>(a)
</pre></div>
</section>


<section>
<h2 id="___sec19">Code for implementing Euler's method </h2>
In the code here we implement this simple Eurler scheme choosing a value for \( D=0.0245 \) m/s.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%"><span></span><span style="color: #228B22"># Common imports</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">pandas</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">pd</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">import</span> *
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">os</span>

<span style="color: #228B22"># Where to save the figures and data files</span>
PROJECT_ROOT_DIR = <span style="color: #CD5555">&quot;Results&quot;</span>
FIGURE_ID = <span style="color: #CD5555">&quot;Results/FigureFiles&quot;</span>
DATA_ID = <span style="color: #CD5555">&quot;DataFiles/&quot;</span>

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(PROJECT_ROOT_DIR):
    os.mkdir(PROJECT_ROOT_DIR)

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(FIGURE_ID):
    os.makedirs(FIGURE_ID)

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(DATA_ID):
    os.makedirs(DATA_ID)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">image_path</span>(fig_id):
    <span style="color: #8B008B; font-weight: bold">return</span> os.path.join(FIGURE_ID, fig_id)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">data_path</span>(dat_id):
    <span style="color: #8B008B; font-weight: bold">return</span> os.path.join(DATA_ID, dat_id)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">save_fig</span>(fig_id):
    plt.savefig(image_path(fig_id) + <span style="color: #CD5555">&quot;.png&quot;</span>, <span style="color: #658b00">format</span>=<span style="color: #CD5555">&#39;png&#39;</span>)


g = <span style="color: #B452CD">9.80655</span> <span style="color: #228B22">#m/s^2</span>
D = <span style="color: #B452CD">0.00245</span> <span style="color: #228B22">#m/s</span>
DeltaT = <span style="color: #B452CD">0.1</span>
<span style="color: #228B22">#set up arrays </span>
tfinal = <span style="color: #B452CD">0.5</span>
n = ceil(tfinal/DeltaT)
<span style="color: #228B22"># define scaling constant vT</span>
vT = sqrt(g/D)
<span style="color: #228B22"># set up arrays for t, a, v, and y and we can compare our results with analytical ones</span>
t = np.zeros(n)
a = np.zeros(n)
v = np.zeros(n)
y = np.zeros(n)
yanalytic = np.zeros(n)
<span style="color: #228B22"># Initial conditions</span>
v[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0.0</span>  <span style="color: #228B22">#m/s</span>
y[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">10.0</span> <span style="color: #228B22">#m</span>
yanalytic[<span style="color: #B452CD">0</span>] = y[<span style="color: #B452CD">0</span>]
<span style="color: #228B22"># Start integrating using Euler&#39;s method</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n-<span style="color: #B452CD">1</span>):
    <span style="color: #228B22"># expression for acceleration</span>
    a[i] = -g + D*v[i]*v[i]
    <span style="color: #228B22"># update velocity and position</span>
    y[i+<span style="color: #B452CD">1</span>] = y[i] + DeltaT*v[i]
    v[i+<span style="color: #B452CD">1</span>] = v[i] + DeltaT*a[i]
    <span style="color: #228B22"># update time to next time step and compute analytical answer</span>
    t[i+<span style="color: #B452CD">1</span>] = t[i] + DeltaT
    yanalytic[i+<span style="color: #B452CD">1</span>] = y[<span style="color: #B452CD">0</span>]-(vT*vT/g)*log(cosh(g*t[i+<span style="color: #B452CD">1</span>]/vT))
    <span style="color: #8B008B; font-weight: bold">if</span> ( y[i+<span style="color: #B452CD">1</span>] &lt; <span style="color: #B452CD">0.0</span>):
        <span style="color: #8B008B; font-weight: bold">break</span>
a[n-<span style="color: #B452CD">1</span>] = -g + D*v[n-<span style="color: #B452CD">1</span>]*v[n-<span style="color: #B452CD">1</span>]
data = {<span style="color: #CD5555">&#39;t[s]&#39;</span>: t,
        <span style="color: #CD5555">&#39;y[m]&#39;</span>: y-yanalytic,
        <span style="color: #CD5555">&#39;v[m/s]&#39;</span>: v,
        <span style="color: #CD5555">&#39;a[m/s^2]&#39;</span>: a
        }
NewData = pd.DataFrame(data)
display(NewData)
<span style="color: #228B22">#finally we plot the data</span>
fig, axs = plt.subplots(<span style="color: #B452CD">3</span>, <span style="color: #B452CD">1</span>)
axs[<span style="color: #B452CD">0</span>].plot(t, y, t, yanalytic)
axs[<span style="color: #B452CD">0</span>].set_xlim(<span style="color: #B452CD">0</span>, tfinal)
axs[<span style="color: #B452CD">0</span>].set_ylabel(<span style="color: #CD5555">&#39;y and exact&#39;</span>)
axs[<span style="color: #B452CD">1</span>].plot(t, v)
axs[<span style="color: #B452CD">1</span>].set_ylabel(<span style="color: #CD5555">&#39;v[m/s]&#39;</span>)
axs[<span style="color: #B452CD">2</span>].plot(t, a)
axs[<span style="color: #B452CD">2</span>].set_xlabel(<span style="color: #CD5555">&#39;time[s]&#39;</span>)
axs[<span style="color: #B452CD">2</span>].set_ylabel(<span style="color: #CD5555">&#39;a[m/s^2]&#39;</span>)
fig.tight_layout()
save_fig(<span style="color: #CD5555">&quot;EulerIntegration&quot;</span>)
plt.show()
</pre></div>
<p>
Try different values for \( \Delta t \) and study the difference between the exact solution and the numerical solution.
</section>


<section>
<h2 id="___sec20">Simple extension, the Euler-Cromer method </h2>

<p>
The Euler-Cromer method is a simple variant of the standard Euler
method. We use the newly updated velocity \( v_{i+1} \) as an input to the
new position, that is, instead of

<p>&nbsp;<br>
$$
y_{i+1} = y_i+\Delta t v_i,
$$
<p>&nbsp;<br>

and
<p>&nbsp;<br>
$$
v_{i+1} = v_i+\Delta t a_i,
$$
<p>&nbsp;<br>

we use now the newly calculate for \( v_{i+1} \) as input to \( y_{i+1} \), that is 
we compute first 
<p>&nbsp;<br>
$$
v_{i+1} = v_i+\Delta t a_i,
$$
<p>&nbsp;<br>

and then
<p>&nbsp;<br>
$$
y_{i+1} = y_i+\Delta t v_{i+1},
$$
<p>&nbsp;<br>

<p>
Implementing the Euler-Cromer method yields a simple change to the previous code. We only need to change the following line in the loop over time
steps
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%"><span></span><span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n-<span style="color: #B452CD">1</span>):
    <span style="color: #228B22"># more codes in between here</span>
    v[i+<span style="color: #B452CD">1</span>] = v[i] + DeltaT*a[i]
    y[i+<span style="color: #B452CD">1</span>] = y[i] + DeltaT*v[i+<span style="color: #B452CD">1</span>]
    <span style="color: #228B22"># more code</span>
</pre></div>
</section>



</div> <!-- class="slides" -->
</div> <!-- class="reveal" -->

<script src="reveal.js/lib/js/head.min.js"></script>
<script src="reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

    // Display navigation controls in the bottom right corner
    controls: true,

    // Display progress bar (below the horiz. slider)
    progress: true,

    // Display the page number of the current slide
    slideNumber: true,

    // Push each slide change to the browser history
    history: false,

    // Enable keyboard shortcuts for navigation
    keyboard: true,

    // Enable the slide overview mode
    overview: true,

    // Vertical centering of slides
    //center: true,
    center: false,

    // Enables touch navigation on devices with touch input
    touch: true,

    // Loop the presentation
    loop: false,

    // Change the presentation direction to be RTL
    rtl: false,

    // Turns fragments on and off globally
    fragments: true,

    // Flags if the presentation is running in an embedded mode,
    // i.e. contained within a limited portion of the screen
    embedded: false,

    // Number of milliseconds between automatically proceeding to the
    // next slide, disabled when set to 0, this value can be overwritten
    // by using a data-autoslide attribute on your slides
    autoSlide: 0,

    // Stop auto-sliding after user input
    autoSlideStoppable: true,

    // Enable slide navigation via mouse wheel
    mouseWheel: false,

    // Hides the address bar on mobile devices
    hideAddressBar: true,

    // Opens links in an iframe preview overlay
    previewLinks: false,

    // Transition style
    transition: 'default', // default/cube/page/concave/zoom/linear/fade/none

    // Transition speed
    transitionSpeed: 'default', // default/fast/slow

    // Transition style for full page slide backgrounds
    backgroundTransition: 'default', // default/none/slide/concave/convex/zoom

    // Number of slides away from the current that are visible
    viewDistance: 3,

    // Parallax background image
    //parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

    // Parallax background size
    //parallaxBackgroundSize: '' // CSS syntax, e.g. "2100px 900px"

    theme: Reveal.getQueryHash().theme, // available themes are in reveal.js/css/theme
    transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/none

});

Reveal.initialize({
    dependencies: [
        // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
        { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },

        // Interpret Markdown in <section> elements
        { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },

        // Syntax highlight for <code> elements
        { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

        // Zoom in and out with Alt+click
        { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },

        // Speaker notes
        { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },

        // Remote control your reveal.js presentation using a touch device
        //{ src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } },

        // MathJax
        //{ src: 'reveal.js/plugin/math/math.js', async: true }
    ]
});

Reveal.initialize({

    // The "normal" size of the presentation, aspect ratio will be preserved
    // when the presentation is scaled to fit different resolutions. Can be
    // specified using percentage units.
    width: 1170,  // original: 960,
    height: 700,

    // Factor of the display size that should remain empty around the content
    margin: 0.1,

    // Bounds for smallest/largest possible scale to apply to content
    minScale: 0.2,
    maxScale: 1.0

});
</script>

<!-- begin footer logo
<div style="position: absolute; bottom: 0px; left: 0; margin-left: 0px">
<img src="somelogo.png">
</div>
     end footer logo -->



</body>
</html>
